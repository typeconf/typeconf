import { CompilerHost, EmitContext, emitFile, resolvePath } from "@typespec/compiler";
import * as path from "./pathlib.js";
import { typescriptEmit } from "./typescript-emitter.js";
import { zodEmit } from "./zod-emitter.js";
import * as jsonc from 'jsonc-parser';

async function fileExists(host: CompilerHost, filePath: string): Promise<boolean> {
  return await host.stat(filePath).then(() => true).catch(() => false);
}

async function readJsoncFile<T>(host: CompilerHost, filePath: string): Promise<T | null> {
  const exists = await fileExists(host, filePath);
  if (!exists) return null;
  
  const content = await host.readFile(filePath).then(file => file.text);
  try {
    return jsonc.parse(content) as T;
  } catch (e) {
    console.log(`Failed to parse JSON from ${filePath}:`, e);
    return null;
  }
}

async function findClosestTsconfig(host: CompilerHost, startDir: string): Promise<string | null> {
  let currentDir = await host.realpath(startDir);
  const root = currentDir.split(/[/\\]/)[0] + '/';

  while (currentDir !== root) {
    const tsconfigPath = path.join(currentDir, 'tsconfig.json');
    const exists = await fileExists(host, tsconfigPath);
    if (exists) {
      return tsconfigPath;
    }
    currentDir = path.dirname(currentDir);
  }

  // Check root directory as well
  const rootTsconfig = path.join(root, 'tsconfig.json');
  return await fileExists(host, rootTsconfig) ? rootTsconfig : null;
}

interface TsConfig {
  compilerOptions?: {
    moduleResolution?: string;
  };
}

async function shouldOmitExtensions(host: CompilerHost, projectDir: string): Promise<boolean> {
  const tsconfigPath = await findClosestTsconfig(host, projectDir);
  if (!tsconfigPath) {
    console.log("No tsconfig.json found in directory tree, assuming bundler module resolution.");
    return true;
  }

  const tsconfig = await readJsoncFile<TsConfig>(host, tsconfigPath);
  if (!tsconfig) {
    console.log("Failed to read tsconfig.json, assuming bundler module resolution.");
    return true;
  }

  const moduleResolution = tsconfig.compilerOptions?.moduleResolution;
  return moduleResolution === 'bundler' || 
         moduleResolution === 'node16' || 
         moduleResolution === 'nodenext';
}

async function findConfigFiles(host: CompilerHost, startDir: string, visited: Set<string> = new Set()): Promise<string[]> {
  const configFiles: string[] = [];
  const excludedDirs = ['dist', 'out', 'types', 'node_modules'];
  
  try {
    const files = await host.readDir(startDir);
    
    for (const file of files) {
      const fullPath = path.join(startDir, file);
      if (visited.has(fullPath)) {
        continue;
      }
      visited.add(fullPath);
      
      const fileInfo = await host.stat(fullPath);
      if (fileInfo.isDirectory() && !excludedDirs.includes(file)) {
        const nestedFiles = await findConfigFiles(host, fullPath, visited);
        configFiles.push(...nestedFiles);
      } else if (fileInfo.isFile() && file.endsWith('.config.ts')) {
        configFiles.push(fullPath);
      }
    }
  } catch (error) {
    console.warn(`Warning: Could not read directory ${startDir}:`, error);
  }
  
  return configFiles;
}

export async function $onEmit(context: EmitContext) {
  if (context.program.compilerOptions.noEmit) {
    return;
  }

  const parentDir = path.dirname(context.emitterOutputDir);
  const omitExtensions = await shouldOmitExtensions(context.program.host, parentDir);
  console.log("Using bundler module resolution:", omitExtensions);
  
  const extension = omitExtensions ? '' : '.js';
  const configFiles = await findConfigFiles(context.program.host, parentDir);
  
  // Generate imports for all found config files
  const configImports = configFiles.map(filePath => {
    const relativePath = path.relative(context.emitterOutputDir, filePath);
    // Remove .ts extension and ensure proper path format
    const importPath = relativePath.replace(/\.ts$/, extension);
    const fullPath = path.relative(parentDir, filePath).replace(/\.config\.ts$/, '');
    const configAlias = fullPath.split('/').map(part => {
      // Convert kebab-case to camelCase for each part
      return part.split('-').map((word, i) => 
        i === 0 ? word : word.charAt(0).toUpperCase() + word.slice(1)
      ).join('');
    }).join('');
    return `export { default as ${configAlias}Config } from '${importPath}'`;
  }).join('\n');

  await emitFile(context.program, {
    path: resolvePath(context.emitterOutputDir, "index.ts"),
    content: `// generated by Typeconf, DO NOT EDIT
import fs from 'fs';

export * from './all${extension}' // Your config types
${configImports}
`,
  });
  await typescriptEmit(context);
  await zodEmit(context);
}
